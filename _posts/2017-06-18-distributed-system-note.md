---
layout: post
tags : [分布式, web架构, nosql, elasticsearch, redis, 集群, kafka, couchbase]
title: 分布式系统浅析

---

## 分布式系统

#### 目标

* 提高系统伸缩性
* 提高性能: 分布式意味着可以使用更多的计算机资源, 提高并发能力
* 提高可扩展性

#### 分布式带来的问题

* 服务调用必须走网络
* 分离粒度越小, 服务器越多, 服务宕机的概率也就越大
* 分布式环境中数据一致性和事务难度增大

分布式需要量力而行, 切莫为了分布式而分布式

#### 分布式系统场景

* 分布式应用和服务
* 分布式静态资源 [js css 多个域名, 独立静态资源域名]
* 分布式数据和存储 [Nosql/分布式文件系统]
* 分布式计算 [deal service 消息分级]
* 分布式配置
* 分布式锁

## Why

* 技术选型
* 系统设计
* 资源评估
* 权衡

---

## 分布式系统理论

* 异常是常态: 服务器宕机, 网络异常, 磁盘故障

* 请求三态: 成功, 失败, 超时

  超时不等同于失败. 超时处理: 不断查询之前操作状态/设计幂等请求


### ACID

### CAP

<img src="/assets/images/distributed/cap.jpg" />

* C 一致性: 数据在多个副本之间是否能够保持一致的特性
* A 可用性: 在任何时刻对大规模的数据读写操作都能保证在限定的延时内返回合理结果
* P 分区容忍性: 当部分节点无法互通出现网络分区现象，但是整个系统还是可以对外提供服务


### BASE

* 基本可用（Basically Available）
* 软状态（ Soft State）
* 最终一致性（ Eventual Consistency）

---

## 一致性协议

* 两阶段提交
* 三阶段提交
* 向量时钟
* RWN协议
* Paxos协议
* Raft协议


---

## 术语

* 机器节点(Node)

* Rebalance: online-rebalancing/auto-sharding

* 分区容错(Partition Tolerance)

* 逻辑分区: key空间/Bucket/Index/Topic

* 数据分片(Partition): Slot/vBuckets/Shard/Partition

* 数据路由(Routing):

  * 哈希分片(Hash Partition) :

    1) 哈希取模(Round Robin): `H(key)=hash(key) mod lengthOfNode`: 未区分node和Partition角色, Node增删将导致hash不稳定

    2) 虚拟桶(Virtual Buckets): `Key->Partition` `Partition->Node`

    3) 一致性哈希(Consistent Hashing): 

  * 范围分片(Range Partition)

* 复制(Replication): 按照复制粒度, 可分为节点复制和分片复制

* 复制策略: 常见的是同步和异步, 异步可以有多种权衡策略

* 失效转移(Failover)

* 读扩展

* 向量时钟, WNR

* 事务

* 乐观锁

* 悲观锁

* 持久化(Durability)

<img style="max-width:120%" src="/assets/images/distributed/big_pic.png" />

---

## 概念

#### 一致性哈希

要解决的问题:

1. 散列的不变性
2. 异常以后的分散性

<img src="/assets/images/distributed/consistent_hash_1.png" />

问题:

1. 新加入一个节点后, 新节点和分离节点的负载是其他节点的一半, 负载不均衡
2. 性能高和性能低的机器, 负载需要不同

改进: 引入虚拟层, 虚拟节点

<img src="/assets/images/distributed/consistent_hash_2.png" />

稳定性分析: N 个node的集群, 新增一个node, 数据继续命中原node的概率

* 哈希取模: 1/(N+1)
* 一致性哈希: N/(N+1)

#### 向量时钟

使用向量时钟的Nosql: Dynamo, Riak

<img src="/assets/images/distributed/vector_clock.png" />

* R 一次成功读操作中最少参与的节点数目
* W 一次成功写操作中最少参与的节点数目
* N 节点数目

当W+R > N，写成功需要的副本数 + 读成功需要的副本数 > 副本总数，则能保证最终一致性.

#### 并发情况下的写丢失

<img width="50%" src="/assets/images/distributed/write_lost.png" />

解决方案:

1. 悲观锁
2. 乐观锁

---

## CouchBase

#### 集群结构

<img src="/assets/images/distributed/node_cb.png" />

#### 分片

<img src="/assets/images/distributed/partition_cb.png" />

#### 复制

<img src="/assets/images/distributed/replication_cb.png" />

#### Rebalance

<img src="/assets/images/distributed/rebalance_cb.png" />

---

## Elasticsearch

#### Node, 分片, 复制

<img src="/assets/images/distributed/node_partition_replication_es.png" />

#### Auto Sharding

<img src="/assets/images/distributed/auto_sharding_es.png" />

<img src="/assets/images/distributed/auto_sharding_es_2.png" />

#### 失效转移

<img src="/assets/images/distributed/failover_es.png" />

#### Client-Node 交互

协调node转发

<img src="/assets/images/distributed/client-node-es.png" />

mget:

<img src="/assets/images/distributed/client-node-mget-es.png" />

#### 副本同步/写安全/复制策略(sync)

协调node转发+同步复制(同步的目标是修改后的完整文档, 而不是修改操作)

<img src="/assets/images/distributed/sync-es.png" />

批量写:

<img src="/assets/images/distributed/sync-es-bulk-write-es.png" />


---

以下是几种分布式系统的比较:


<div class="table-wrap"><table class="confluenceTable tablesorter tablesorter-default"><thead><tr class="tablesorter-headerRow"><th class="confluenceTh sortableHeader tablesorter-headerAsc" data-column="0" tabindex="0" unselectable="on" style="user-select: none;"><div class="tablesorter-header-inner">&nbsp;</div></th><th colspan="1" class="confluenceTh sortableHeader" data-column="1" tabindex="0" unselectable="on" style="user-select: none;"><div class="tablesorter-header-inner"><strong>描述</strong></div></th><th colspan="1" class="confluenceTh sortableHeader" data-column="2" tabindex="0" unselectable="on" style="user-select: none;"><div class="tablesorter-header-inner">CAP</div></th><th class="confluenceTh sortableHeader" data-column="3" tabindex="0" unselectable="on" style="user-select: none;"><div class="tablesorter-header-inner"><strong>Redis (Cluster)</strong></div></th><th class="confluenceTh sortableHeader" data-column="4" tabindex="0" unselectable="on" style="user-select: none;"><div class="tablesorter-header-inner"><strong>CouchBase</strong></div></th><th class="confluenceTh sortableHeader" data-column="5" tabindex="0" unselectable="on" style="user-select: none;"><div class="tablesorter-header-inner">ES</div></th><th colspan="1" class="confluenceTh sortableHeader" data-column="6" tabindex="0" unselectable="on" style="user-select: none;"><div class="tablesorter-header-inner">Kafka</div></th></tr></thead><tbody><tr><td colspan="1" class="confluenceTd"><h2 id="id-分布式系统浅析2-API"><strong>API</strong></h2></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd"><span>CAP</span></td><td class="confluenceTd">长时间(A)提供高吞吐量的(P)正确(C)读写服务</td><td colspan="1" class="confluenceTd"><p>&nbsp;</p></td><td class="confluenceTd"><p>Redis主从/哨兵: CP</p><p>Redis Cluster: AP</p></td><td class="confluenceTd"><p><span>CP:</span></p><p><span>复制数据默认不提供服务 (可用性A降低)</span></p><p><span><span style="color: rgb(37,37,37);">replica仅作为高可用, 默认不提供读 (一致性C高)</span></span></p><p><span><br></span></p></td><td class="confluenceTd"><a class="external-link" href="https://discuss.elastic.co/t/elasticsearch-and-the-cap-theorem/15102" rel="nofollow">https://discuss.elastic.co/t/elasticsearch-and-the-cap-theorem/15102</a></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd"><span style="color: rgb(0,0,255);">Client-Node 交互</span></td><td class="confluenceTd"><p>1)&nbsp;直连: 通常client持有Routing Map</p><p>延迟低</p><p>2) 代理: 延迟高</p><p>&nbsp;</p></td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd"><p><span>直连, 无代理</span></p><p><span><span style="color: rgb(37,37,37);">Smart Client(<span style="color: rgb(37,37,37);">client-side key hash</span>)</span></span></p><p>node 重定向: ASK/MOVE, 对client不透明</p></td><td class="confluenceTd"><p>直连, 无代理</p><p><span style="color: rgb(37,37,37);">Smart Client(<span style="color: rgb(37,37,37);">client-side key hash</span>)</span></p></td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">协调者转发, 对client透明</span></p><p><span style="color: rgb(68,68,68);">任何阶段都可以响应任何client请求</span></p><p>node(协调节点)计算routing后转发到相应node, 数据返回协调者后, 协调者再返回client</p><p>写:受<span>Majority Quorum限制</span></p><p>读:协调者轮询<span style="color: rgb(68,68,68);">有数据的分片</span></p><p>&nbsp;</p><p>client建议是轮询node(作为协调节点)</p></td><td class="confluenceTd"><p>TODO</p></td></tr><tr><td colspan="1" class="confluenceTd">client和集群间</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p><span>基于主键</span></p><p>集群节点不代理其他节点, 而是指导client进行跳转找到正确的node (moved, asked)</p><p>异步复制, 节点写入不等待其他节点确认, 直接返回客户端(除非明确要求WAIT)</p><p>&nbsp;</p></td><td colspan="1" class="confluenceTd"><ol><li>基于主键<span class="keyword apiname" style="color: rgb(120,120,120);">&nbsp;</span></li><li>N1QL</li><li><span style="color: rgb(37,37,37);">Full Text Search(需要插件?)</span></li></ol><p><span style="color: rgb(37,37,37);">没有用于CURD 的 restful API, 有用于管理的http api<br></span><span style="color: rgb(37,37,37);"><br></span><br><span style="color: rgb(37,37,37);"><br></span></p></td><td colspan="1" class="confluenceTd"><p><span>1) RESTful API: <span>默认端口</span><span style="color: rgb(85,85,85);">9200</span></span></p><p><span>2) java 2中客户端: 默认端口9300, <span style="color: rgb(85,85,85);">协议: </span><span style="color: rgb(85,85,85);">Elasticsearch Transport Protocol</span></span></p><p><span> 1) node client: <span>以无数据节点(none data node)身份加入集群，换言之，它自己不存储任何数据，但是它知道数据在集群中的具体位置，并且能够直接转发请求到对应的节点上</span></span></p><p><span> 2) Transport client: <span>不加入集群，只是简单转发请求给集群中的节点</span></span></p><p>&nbsp;</p><p><span style="color: rgb(85,85,85);"><br></span></p></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">CURD</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>Insert</p><p>Upsert</p><p>Replace</p><p>Get</p><p><span>Remove</span></p></td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(85,85,85);"><span style="color: rgb(85,85,85);">查询: GET /{index}/{type}/{id}</span></span></p><p><span style="color: rgb(85,85,85);">新建: PUT /{index}/{type}/{id} (文档不存在)</span></p><p><span style="color: rgb(85,85,85);">全量更新: PUT /{index}/{type}/{id} (文档存在)</span></p><p><span style="color: rgb(85,85,85);">局部更新: POST /{index}/{type}/{id}/_update</span></p><p><span style="color: rgb(0,0,0);">删除: DELETE /{index}/{type}/{id}</span></p><p><span style="color: rgb(85,85,85);">&nbsp;</span></p><p><span style="color: rgb(85,85,85);">upsert: 更新或新建</span></p></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd"><p><span style="color: rgb(0,0,255);">Node</span></p><p>&nbsp;</p></td><td class="confluenceTd"><span>通常是指独立的服务器或者独立的进程</span></td><td class="confluenceTd">&nbsp;水平伸缩性</td><td class="confluenceTd"><p>对等节点</p><p>节点属性:</p><p>节点ID(初次启动获得, 存于配置文件)</p><p>&nbsp;</p><p>&nbsp;</p></td><td class="confluenceTd"><p>对等节点(<span style="color: rgb(37,37,37);">peer-to-peer node</span>)</p><p>所有节点类型和结构相同, 不过会选择一个orchestrator</p><p>Node提供的服务(可配置node部分开启, <span style="color: rgb(37,37,37);">MDS</span>):</p><p>Cluster manager</p><p>Data service: KV CRUD</p><p>Index service</p><p>Query service:<span style="color: rgb(37,37,37);">N1QL</span></p><p>&nbsp;</p></td><td class="confluenceTd"><p><span>对等节点(</span><span style="color: rgb(37,37,37);">peer-to-peer node</span><span>)</span></p><p>集群选举一个主节点: <span style="color: rgb(68,68,68);">负责管理集群范围内的所有变更，例如增加、删除索引，或者增加、删除节点等</span></p><p><span style="color: rgb(68,68,68);"><br></span></p><p>&nbsp;</p></td><td class="confluenceTd"><p><span style="color: rgb(0,0,255);">Broker</span></p><p>其中一个Broker会被选举为Controller，主要负责Partition管理和副本状态管理，也会执行类似于重分配Partition之类的管理任务</p></td></tr><tr><td class="confluenceTd"><p><span style="color: rgb(0,0,255);">Node 伸缩</span></p><p><span style="color: rgb(0,0,255);">(Rebalance/</span></p><p><span style="color: rgb(0,0,255);">Reshard)</span></p></td><td class="confluenceTd"><p><span style="color: rgb(37,37,37);">实际操作: </span><span style="color: rgb(37,37,37);">增删node时, 需要迁移数据</span></p><p>2个原因:</p><p>1) 需要扩容</p><p>2) node 失效</p><p><span>分片(P</span><span style="color: rgb(37,37,37);">artition</span><span>)是<span style="color: rgb(37,37,37);">Rebalance迁移的目标</span></span></p><p>&nbsp;</p></td><td class="confluenceTd">&nbsp;P</td><td class="confluenceTd"><p><span><span>最多</span><span style="color: rgb(62,67,73);">16384个node</span></span></p><p><span>online rebalancing</span></p><p><span>支持(手动)在线reshard, </span><span>把哈希槽从一个节点移到另一个节点</span></p><p>&nbsp;</p></td><td class="confluenceTd"><p><span>online rebalancing, <span style="color: rgb(37,37,37);">无需服务停机</span></span></p><p><span><span style="color: rgb(37,37,37);"><span>auto-sharding</span></span></span></p><p><span><span style="color: rgb(37,37,37);"><span><br></span></span></span></p><p>&nbsp;</p><p><span>以 vBucket 为单位的主从备份, 可以方便灵活的把数据的子集在不同节点上移动，以实现集群动态管理</span></p><p>&nbsp;</p></td><td class="confluenceTd"><p><span>online rebalancing, </span><span style="color: rgb(37,37,37);">无需服务停机</span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">auto-sharding: 自动检测和删除失败的节点，并重新组织集群</span></span></p></td><td class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">node间</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>node在cluster bus上使用&nbsp;gossip 协议来发布广播消息，通知配置变更</p><p>Redis 集群是一个网状结构，每个节点都通过 TCP 连接跟其他每个节点连接</p><p>每个节点都有 N-1 个流出的 TCP 连接，和 N-1 个流入的连接。 这些 TCP 连接会永久保持</p></td><td colspan="1" class="confluenceTd"><span style="color: rgb(37,37,37);">DCP</span></td><td colspan="1" class="confluenceTd"><p><span>gossip 协议 (单播时?)</span></p><p>端口<span style="color: rgb(68,68,68);">9300</span></p></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">Sub-Document</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>支持原子性 <a class="external-link" href="https://developer.couchbase.com/documentation/server/4.6/sdk/subdocument-operations.html" rel="nofollow">https://developer.couchbase.com/documentation/server/4.6/sdk/subdocument-operations.html</a></p><span style="color: rgb(36,41,46);">读: LookupIn: (可能部分成功)</span><p>写: MutateIn: (原子操作, 如果有有任何path失败, 全量回滚)</p></td><td colspan="1" class="confluenceTd">支持文档部分更新, 内部: 检索-修改-重建索引</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">value数值增减</td><td colspan="1" class="confluenceTd">原子操作</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>incr</p><p>incrby</p><p>incrbyfloat</p></td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(0,0,0);">counter</span></p><p><span style="color: rgb(0,0,0);">原子操作, 无法指定cas</span></p></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">N/A</td></tr><tr><td class="confluenceTd">web管理</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">监控工具: TODO</td><td class="confluenceTd">自带webconsole</td><td class="confluenceTd"><span style="color: rgb(68,68,68);">Sense, <span style="color: rgb(68,68,68);">Marvel, elasticsearch-head</span></span></td><td class="confluenceTd">yahoo/kafka-manager</td></tr><tr><td colspan="1" class="confluenceTd"><span style="color: rgb(0,0,255);">乐观锁</span></td><td colspan="1" class="confluenceTd"><p>Compare And Swap</p><p>CAS是乐观锁的一种形式</p><p>代表数据当前状态</p><p><span style="color: rgb(37,37,37);">guideline: </span></p><p><span style="color: rgb(37,37,37);">1)检索 和 重建索引 步骤的间隔越小，变更冲突的机会越小</span></p><p><span style="color: rgb(37,37,37);">2)冲突后通常方案是重新获取并重试</span></p><p>&nbsp;</p></td><td colspan="1" class="confluenceTd">C</td><td colspan="1" class="confluenceTd"><p>WATCH key [key ...]</p><p>需要结合事务</p></td><td colspan="1" class="confluenceTd"><p><a class="external-link" href="https://developer.couchbase.com/documentation/server/4.6/sdk/concurrent-mutations-cluster.html" rel="nofollow">CAS </a></p><p>支持</p><p>每次文档访问时作为<span style="color: rgb(37,37,37);">metadata信息返回</span></p><p><span style="color: rgb(37,37,37);">在执行修改操作时可以作为参数传递到server</span></p></td><td colspan="1" class="confluenceTd"><p>文档更新时, <span style="color: rgb(85,85,85);">_version递增</span></p><p><span style="color: rgb(85,85,85);">在修改文档时, 传递version实现乐观锁控制</span></p><p><span style="color: rgb(85,85,85);">除了默认的_version, 还支持使用外部系统版本号作为乐观锁</span></p><p><span style="color: rgb(85,85,85);"><br></span></p><p><span style="color: rgb(85,85,85);">支持参数:</span></p><pre class="programlisting prettyprint lang-js prettyprinted"><span class="pln" style="color: rgb(0,0,0);">retry_on_conflict=N 自动重试N次</span></pre><p><span style="color: rgb(85,85,85);">&nbsp;</span></p></td><td colspan="1" class="confluenceTd"><span style="color: rgb(85,85,85);">broker是无状态的, 它不需要标记哪些消息被哪些consumer过，不需要通过broker去保证同一个consumer group只有一个consumer能消费某一条消息，因此也就不需要锁机制</span></td></tr><tr><td colspan="1" class="confluenceTd"><span style="color: rgb(0,0,255);">事务</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">C</td><td colspan="1" class="confluenceTd"><p>单机支持, 满足原子性执行, 但不支持回滚</p><pre>MULTI 开启事务</pre><p>......</p><pre class="__reader_view_article_wrap_0030123807745761066__">EXEC 执行事务</pre><pre class="__reader_view_article_wrap_0030123807745761066__">WATCH key [key ...] 乐观锁可以实现中断事务</pre></td><td colspan="1" class="confluenceTd">无</td><td colspan="1" class="confluenceTd">不支持ACID事务</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd"><span style="color: rgb(255,0,0);">以下内容未完成</span></td><td colspan="1" class="confluenceTd"><span style="color: rgb(255,0,0);">以下内容未完成</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd"><span>伸缩操作</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p><span>增加节点: 手动</span><span style="color: rgb(136,0,0);">meet, </span><span>缺乏自动发现</span></p><p><span><span style="color: rgb(68,68,68);">redis-trib.rb add-node </span></span></p><p><span><span style="color: rgb(63,63,63);">redis-trib.rb reshard</span></span></p></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd"><span>健康检查</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><pre class="programlisting prettyprint lang-js">1)集群健康检查</pre><pre class="programlisting prettyprint lang-js">GET /_cluster/health</pre><pre class="programlisting prettyprint lang-bash prettyprinted"><span class="pln" style="color: rgb(0,0,0);">GET _cluster</span><span class="pun" style="color: rgb(102,102,0);">/</span><span class="pln" style="color: rgb(0,0,0);">health</span><span class="pun" style="color: rgb(102,102,0);">?</span><span class="pln" style="color: rgb(0,0,0);">level</span><span class="pun" style="color: rgb(102,102,0);">=</span><span class="pln" style="color: rgb(0,0,0);">indices</span></pre><pre class="programlisting prettyprint lang-bash prettyprinted"><span class="pln" style="color: rgb(0,0,0);">GET _cluster</span><span class="pun" style="color: rgb(102,102,0);">/</span><span class="pln" style="color: rgb(0,0,0);">health</span><span class="pun" style="color: rgb(102,102,0);">?</span><span class="pln" style="color: rgb(0,0,0);">level</span><span class="pun" style="color: rgb(102,102,0);">=</span><span class="pln" style="color: rgb(0,0,0);">shards</span></pre><pre class="programlisting prettyprint lang-js">status:</pre><p><span class="term" style="color: rgb(43,69,144);"><code class="literal">green:</code></span>所有的主分片和副本分片都正常运行</p><p><span class="term" style="color: rgb(43,69,144);"><code class="literal">yellow</code></span>所有的主分片都正常运行，但不是所有的副本分片都正常运行</p><p><span class="term" style="color: rgb(43,69,144);"><code class="literal">red</code></span>有主分片没能正常运行</p><p>2)node统计</p><pre class="programlisting prettyprint lang-bash prettyprinted"><span class="pln" style="color: rgb(0,0,0);">GET _nodes</span><span class="pun" style="color: rgb(102,102,0);">/</span><span class="pln" style="color: rgb(0,0,0);">stats </span></pre><p>3) 集群统计</p><pre class="programlisting prettyprint lang-js prettyprinted"><span class="pln" style="color: rgb(0,0,0);">GET _cluster</span><span class="pun" style="color: rgb(102,102,0);">/</span><span class="pln" style="color: rgb(0,0,0);">stats</span></pre><pre class="programlisting prettyprint lang-js prettyprinted"><span class="pln" style="color: rgb(0,0,0);">4)索引统计</span></pre><pre class="programlisting prettyprint lang-js prettyprinted"><span class="pln" style="color: rgb(0,0,0);">GET my_index</span><span class="pun" style="color: rgb(102,102,0);">,</span><span class="pln" style="color: rgb(0,0,0);">another_index</span><span class="pun" style="color: rgb(102,102,0);">/</span><span class="pln" style="color: rgb(0,0,0);">_stats</span></pre></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">内容数值增减</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>hash: hincrby, hincrbyfloat</p><p>zset: zincrby</p><p>&nbsp;</p></td><td colspan="1" class="confluenceTd">sub操作</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd"><p><span style="color: rgb(0,0,255);">分区容错</span></p><p><span style="color: rgb(0,0,255);">(Partition Tolerance)</span></p></td><td class="confluenceTd"><p><span>当出现网络分区(脑裂)时系统也可以继续工作</span></p></td><td class="confluenceTd">&nbsp;P</td><td class="confluenceTd"><p>仅能<span>容忍集群中少数节点的出错</span></p><p>脑裂分区可用条件: 多数master存活+其他master有存活的slave, <span>NODE_TIMEOUT后从提升为主</span></p></td><td class="confluenceTd">node fail时, 该node的数据无法写, 在足够<span>vBucket的分区中, 失效转移完成后集群恢复.</span></td><td class="confluenceTd"><p>discovery.zen.minimum_master_nodes: 用于控制脑裂后的可用集群, 通常设置原则是（master_eligible_nodes / 2）+ 1</p><p>网络分区后, 集群中索引状态, 取决于该分区中是否有完整的分区(primary或者replica都行), 如果不满足, 该索引状态标红.</p><p>&nbsp;</p><p>如果某个分片<span>primary和replica都失效, 集群仍然可以提供其他分片查询.</span></p></td><td class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd"><p><span style="color: rgb(0,0,255);">分片</span></p><p><span style="color: rgb(0,0,255);">(Partition/Shard)</span></p></td><td class="confluenceTd"><p>作用:水平扩展(将负载能力提升为 `单机能力*N`)</p><p>同时提升读写能力</p><p>&nbsp;</p><p><span>复制和分片是正交的</span></p></td><td class="confluenceTd"><p>降低A</p></td><td class="confluenceTd"><p><span style="color: rgb(51,102,255);">Slot</span></p><p><span style="color: rgb(62,67,73);">角色: 分片无差别, 关键在于node的角色</span></p><p>每个<span>Cluster分为<span style="color: rgb(62,67,73);">16384个slot</span></span></p></td><td class="confluenceTd"><p><span style="color: rgb(51,102,255);">vBuckets</span></p><p><span style="color: rgb(37,37,37);">1024 个<span style="color: rgb(37,37,37);">vBuckets</span></span></p><p>&nbsp;</p></td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);"><span style="color: rgb(51,102,255);">Shard</span>(分片): 本身是一个 Lucene 的实例</span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">主分片数在index创建时固定</span></span></p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(68,68,68);">副本分片数量可以随时调整</span></span></p></td><td class="confluenceTd"><p><span style="color: rgb(51,102,255);">Partition</span></p><p>消息在一个Partition中的顺序是有序的，但是Kafka只保证消息在一个Partition中有序，如果要想使整个topic中的消息有序，那么一个topic仅设置一个Partition即可</p><p>Partition是最小并发粒度(对应consumer)</p></td></tr><tr><td class="confluenceTd"><span style="color: rgb(0,0,255);">副本同步/写安全/复制策略(sync)</span></td><td class="confluenceTd"><p>某些场景可以叫做主从同步</p><p>分为:</p><p>1) 多写/双主: 如果不使用一致性协议, 更新顺序无法保证, 数据会出现不一致</p><p>2) 同步主从更新: 强一致性, 高延迟</p><p>3) 异步主从更新: 请求延迟和一致性之前的权衡, 常见权衡策略: <span>Majority Quorum, <span>WNR, <span>ISR</span></span></span></p><p>4) 任意节点更新 TODO</p><p>&nbsp;</p></td><td class="confluenceTd">&nbsp;A, C以及延迟的权衡</td><td class="confluenceTd">&nbsp;<p>存在写丢失的可能, 原因:</p><p>1) 默认异步复制 (好处是速度快)</p><p>2) last failover wins(<span style="color: rgb(102,102,102);">最后选举出的master数据最终替换其它副本</span>)</p><p>示例:</p><p>1) 主写入, 响应client, 但是在同步给从之前挂掉了, 从提升为主, 造成写丢失</p><p>2) 主挂掉, 从提升, 有的客户端还没来得及更新路由, 这时候原来的主复活, 但是还没来得及降为从, 此时接收到写</p><p>3) 一个master不可达, 达到`NODE_TIMEOUT` 将发生故障转移, 但是如果在`NODE_TIMEOUT`之前,</p><p>网络分区修复了, 就不会有写丢失, 但是如果网络分区超过`NODE_TIMEOUT`, 应用在少数派的写将丢失.</p><p>在这之后, 少数派将拒接写入.</p><p>这是为什么redis只能拿来做缓存</p></td><td class="confluenceTd">&nbsp;<span>默认索引和复制都是异步更新</span></td><td class="confluenceTd"><p>默认情况同步更新副本, 强一致性.</p><div class="page" title="Page 147"><div class="layoutArea"><div class="column"><p>&nbsp;</p></div></div></div><p>&nbsp;</p><p><span>Majority Quorum</span></p><p>默认情况, 当<span style="color: rgb(85,85,85);">number_of_replicas&gt;1, </span>主分片需要大多数分片写入成功:</p><p>int( (primary + number_of_replicas) / 2 ) + 1</p><p><span><span>number_of_replicas是Index指定的副本数量</span></span></p><p><span><span>满足以上条件后, es的复制策略是同步更新,写安全</span></span></p><p><span><span>同步的目标是修改后的完整文档, 而不是修改操作</span></span></p></td><td class="confluenceTd"><p><span>follower从leader pull数据, <span style="color: rgb(85,85,85);">Follower在接收到数据后就立马向Leader发送ACK，而非等到数据写入Log中,</span><span> <span>leader收到所有ISR的ACK后, 标记log为commit, Leader将增加HW(<span>High Watermark</span>)并且向Producer发送ACK???</span></span></span></p><p><span><span><span>(<span style="color: rgb(85,85,85);">性能和数据持久化上做了一个比较好的平衡</span>)</span></span></span></p><p><span><span><span><span style="color: rgb(85,85,85);">只有被commit过的消息（offset低于HW的消息）才会暴露给Consumer</span></span></span></span></p><p><span>如果<a class="external-link" href="http://replica.lag.time.max.ms" rel="nofollow">replica.lag.time.max.ms</a> 内 <span>follower没有fetch <span>leader,</span></span></span></p><p><span><span><span>leader将把该<span>follower从Isr中移除</span></span></span></span></p><p>&nbsp;</p><p>Producers:采用异步push方式, 可以通过参数控制是采用同步还是异步方式</p><p><span style="color: rgb(61,70,77);">producer端参数控制:</span></p><p><span style="color: rgb(61,70,77);">acks=0: producer不需要leader发送响应，即producer只管发不管发送成功与否, 延迟低，容易丢失数据</span></p><p><span style="color: rgb(61,70,77);">acks=1：表示leader写入成功（但是并没有刷新到磁盘）后即向producer响应。延迟中等，一旦leader副本挂了，就会丢失数据</span></p><p><span style="color: rgb(61,70,77);">acks=-1/all：表示leader会等待isr列表中所有副本都写入成功才向producer发送响应。延迟高、可靠性高。但是也会丢数据.</span></p><p><span><span><span><span><br></span></span></span></span></p></td></tr><tr><td class="confluenceTd"><span style="color: rgb(0,0,255);">副本同步权衡</span></td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;C</td><td class="confluenceTd"><p>支持同步复制:</p><p>WAIT numslaves timeout</p></td><td class="confluenceTd"><p>API可以调整 replicateTo和persistTo来控制同步复制数据</p></td><td class="confluenceTd"><p><span style="color: rgb(85,85,85);"><span>默认: Majority Quorum+ 同步更新</span></span></p><p>异步: 可以在写url上加上参数?replication=async 实现异步 (但是2.0后移除了)</p><p>异步: 配置项consistent, 同步成功副本数量, 默认是<span>int( (primary + number_of_replicas) / 2 ) + 1</span></p></td><td class="confluenceTd"><p><span style="color: rgb(61,70,77);"><span style="color: rgb(61,70,77);">配置中<span style="color: rgb(61,70,77);">min.insync.replicas (默认1)</span></span></span></p><p><span style="color: rgb(61,70,77);">当acks=-1时, leader写入时, 如果size(<span style="color: rgb(61,70,77);">isr</span>) &lt; <span style="color: rgb(61,70,77);">min.insync.replicas, 则默认不写入</span></span></p></td></tr><tr><td class="confluenceTd">原子性</td><td class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd"><p>文档级别原子性, 所有KV操作都是原子操作</p><p>&nbsp;</p></td><td class="confluenceTd"><span style="color: rgb(68,68,68);">文档级别的变更支持 ACID</span></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd">和关系型数据库比较</td><td class="confluenceTd"><span style="color: rgb(37,37,37);">Database</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd"><p><span style="color: rgb(37,37,37);">单机版0~15, 默认0号<span style="color: rgb(37,37,37);">Database, </span></span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"> Cluster只能使用0号db</span></span></p></td><td class="confluenceTd"><span style="color: rgb(37,37,37);">Bucket</span></td><td class="confluenceTd"><p>Index</p></td><td colspan="1" class="confluenceTd"><span>N/A</span></td></tr><tr><td class="confluenceTd"><p><span style="color: rgb(0,0,255);">复制/副本</span></p><p><span style="color: rgb(0,0,255);">(Replication)</span></p></td><td class="confluenceTd"><p>冗余的一种方式, 提高可用性, 实现容灾(<span style="color: rgb(37,37,37);">disaster recovery</span>)</p><p>有复制, 才能在必要时进行<span style="color: rgb(37,37,37);">Failover</span></p><p>&nbsp;</p><p>为什么需要分角色:</p><p>一致性问题</p><p>主写: 1*N的数据同步</p><p>全写: N*N的数据同步</p></td><td class="confluenceTd"><p>提升A</p><p>使得一致性更难达成.</p></td><td class="confluenceTd"><p>对node进行复制</p><p>角色: master node, slave node</p><p>一主多从</p><p>复制数量为1, 2个node fail时, 集群存活概率:<span style="color: rgb(102,102,102);">1-(1/(N*2-1))&nbsp;</span></p></td><td class="confluenceTd"><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">对分片(<span style="color: rgb(37,37,37);">vBuckets</span>)进行复制</span></span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">角色: <span style="color: rgb(37,37,37);">每个 Bucket 包含 1024 active vBuckets, 1024 replica</span></span></span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">最多支持3个复制, 也就是4份数据</span></span></p><p><span style="color: rgb(37,37,37);">TODO node 挂了以后, 集群存活概率</span></p></td><td class="confluenceTd"><p>对分片(<span style="color: rgb(68,68,68);">shard</span>)进行复制</p><p><span style="color: rgb(68,68,68);">角色:primary shard(主分片), replica shard(副本分片)</span></p></td><td class="confluenceTd"><p><span>对分片(<span>Partition</span></span><span>)进行复制</span></p><p><span><span>角色: leader, follower, Isr</span></span></p><p><span><span>Isr: in-sync, 当前活跃的副本列表, 是Replicas的子集</span></span></p></td></tr><tr><td class="confluenceTd"><p><span style="color: rgb(0,0,255);">失效转移</span></p><p><span style="color: rgb(0,0,255);">(Failover)</span></p></td><td class="confluenceTd"><p>副本的角色提升, 通常发送在Node失效的情况下</p></td><td class="confluenceTd">&nbsp;A</td><td class="confluenceTd">失效的master node对应的slave提升为master (自动)</td><td class="confluenceTd"><p>支持自动/手动</p><p>找到失效节点中的原active <span style="color: rgb(37,37,37);">vBuckets对应的<span style="color: rgb(37,37,37);">replica <span>&nbsp;</span><span style="color: rgb(37,37,37);">vBuckets, 设为<span>active</span></span></span></span></p></td><td class="confluenceTd"><p>自动</p><p>找到失效node中原<span style="color: rgb(68,68,68);">primary shard对应的<span style="color: rgb(68,68,68);">replica, 提升为<span style="color: rgb(68,68,68);">primary.</span></span></span></p></td><td class="confluenceTd"><p>当<span style="color: rgb(61,70,77);">broker失效, 对于该broker上的分片:</span></p><p><span style="color: rgb(61,70,77);">&nbsp;</span>从followers中选举<span style="color: rgb(61,70,77);">leader</span></p></td></tr><tr><td colspan="1" class="confluenceTd"><span style="color: rgb(0,0,255);">悲观锁</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">C</td><td colspan="1" class="confluenceTd">不支持</td><td colspan="1" class="confluenceTd"><span>支持, 但不常用</span></td><td colspan="1" class="confluenceTd"><p>支持(不常用, 挺复杂):</p><p>全局锁</p><p>文档锁</p><p>树锁</p></td><td colspan="1" class="confluenceTd"><span>N/A</span></td></tr><tr><td class="confluenceTd">批量操作</td><td class="confluenceTd"><p>节约网络开销, 通常是非原子性</p><p>存在部分成功部分失败</p></td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd"><p>multiple 操作: 满足原子性. 如mget, mset, hmget,hmset</p><p>pipeline: 非事务性, <span style="color: rgb(37,37,37);">guideline: 不要过大</span></p><p>cluster 不支持不同分片的pipeline, 需要客户端自行实现分组</p></td><td class="confluenceTd"><p><a class="external-link" href="https://developer.couchbase.com/documentation/server/4.6/sdk/batching-operations.html" rel="nofollow">Batching Operations</a></p><p>SDK 并行分组发送</p><p>非事务性</p><p><span style="color: rgb(37,37,37);">guideline: 1M</span></p><p>数据结构: <span style="color: rgb(0,0,0);">gocb</span><span class="token punctuation" style="color: rgb(153,153,153);">.</span><span style="color: rgb(0,0,0);">BulkOp, <span>gocb</span><span class="token punctuation" style="color: rgb(153,153,153);">.*</span><span>Op</span></span></p><p><span style="color: rgb(0,0,0);">执行: bucket.Do</span></p><p><span style="color: rgb(37,37,37);"><br></span></p></td><td class="confluenceTd"><p>1) 批量获取: GET /_mget</p><p>2) bulk API: 可以混合create 、 index 、 update 或 delete</p><p><span style="color: rgb(68,68,68);"><span style="color: rgb(37,37,37);">guideline: </span>最佳值不是一个固定的值, 建议基准测试</span></p></td><td colspan="1" class="confluenceTd">Producers: Kafka支持以消息集合为单位进行批量发送</td></tr><tr><td colspan="1" class="confluenceTd"><span style="color: rgb(0,0,255);">持久化(Durability)</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">A</td><td colspan="1" class="confluenceTd"><p>可选:</p><p>1) Snapshot: 数据可能缺失部分; copy-on-write造成极端情况内存是实际数据的2倍; db文件尺寸小; 恢复快<br>2) AOF: AOF文件非常的庞大; 恢复时间长(用rewrite缓解); 更多的磁盘IO; 数据更完整</p></td><td colspan="1" class="confluenceTd"><p><a class="external-link" href="https://developer.couchbase.com/documentation/server/4.6/sdk/durability.html" rel="nofollow">https://developer.couchbase.com/documentation/server/4.6/sdk/durability.html</a></p><p>持久化和复制是异步进行(可以通过SDK参数控制)</p><p>持久化和复制是可能丢失的: node fail时, disk queue 和 replication queue会丢失</p><p>这是为什么可用性不高</p></td><td colspan="1" class="confluenceTd"><p>文档被索引-&gt;文档加入内存缓存区, 并追加到<span style="color: rgb(68,68,68);">translog-&gt;定期<span style="color: rgb(68,68,68);">refresh</span></span></p><p>&nbsp;</p></td><td colspan="1" class="confluenceTd"><p>每个分区在物理上对应一个文件夹，以`topicName_partitionIndex`的命名方式命名，该文件夹下存储这个分区的所有消息(.log)和索引文件(.index)</p><p>顺序写磁盘</p></td></tr><tr><td colspan="1" class="confluenceTd">持久化/复制</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>*Dura</p><p>参数:</p><p>replicateTo: 复制数量, 最大值是复制集数量</p><p>persistTo: 持久化到硬盘数量,最大值是复制集数量+1, 如果是1表示active node</p></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd"><h2 id="id-分布式系统浅析2-数据模型"><strong>数据模型</strong></h2></td><td class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">数据类型/模型</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>string</p><p>map</p><p>set</p><p>hash</p><p>list</p><p>sortedset(zset)</p></td><td colspan="1" class="confluenceTd"><p>KV</p><p>Document</p><p>另外语言SDK中提供若干api支持基于<span>document的数据类型: <a class="external-link" href="https://developer.couchbase.com/documentation/server/4.6/sdk/go/datastructures.html" rel="nofollow">Data Structures</a></span></p><p><span><span class="ph b" style="color: rgb(37,37,37);">Map</span></span></p><p><span><span class="ph b" style="color: rgb(37,37,37);">List</span></span></p><p><span><span class="ph b" style="color: rgb(37,37,37);"><span class="ph b" style="color: rgb(37,37,37);">Queue(<span style="color: rgb(37,37,37);">FIFO</span>)</span></span></span></p><p><span><span class="ph b" style="color: rgb(37,37,37);"><span class="ph b" style="color: rgb(37,37,37);"><span class="ph b" style="color: rgb(37,37,37);">Set</span></span></span></span></p></td><td colspan="1" class="confluenceTd"><p>文档元数据:</p><p><span style="color: rgb(85,85,85);">_index: 文档所属索引</span></p><p><span style="color: rgb(85,85,85);">_type: 文档类型</span></p><p>_id: 文档id, 和<span style="color: rgb(85,85,85);">_index, <span style="color: rgb(85,85,85);">_type组合可以唯一确定一个文档</span></span></p><p><span style="color: rgb(85,85,85);"><span style="color: rgb(85,85,85);"><span style="color: rgb(85,85,85);">_version: 用于实现乐观锁</span></span></span></p><p><span style="color: rgb(85,85,85);"><span style="color: rgb(85,85,85);"><span style="color: rgb(85,85,85);"><span style="color: rgb(68,68,68);">文档不能被修改, 只能被替换</span></span></span></span></p></td><td colspan="1" class="confluenceTd">TODO 消息结构</td></tr><tr><td class="confluenceTd"><p><span style="color: rgb(0,0,255);">数据路由</span></p><p><span style="color: rgb(0,0,255);">(Routing)</span></p></td><td class="confluenceTd"><p>数据分片后, 数据到node的映射</p><p>通常是两层映射关系:</p><p>key-&gt;分片</p><p>分片-&gt;node</p></td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd"><p>&nbsp;</p><pre><code>HASH_SLOT = CRC16(key) mod 16384</code></pre><pre><code><strong>hash tags功能</strong></code>:<span>&nbsp;`{key_to_hash}.following`</span></pre><p>&nbsp;</p><p>分片数量固定且不能调整</p></td><td class="confluenceTd"><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">Smart Client: 同步 vBucket 表, 在客户端实现负载均衡, 高效应对节点失效</span></span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">Map在node和client都存在(</span><span style="color: rgb(37,37,37);">Client Topology Awareness</span><span style="color: rgb(37,37,37);">)</span></span></p><p><span style="color: rgb(37,37,37);">Cluster Map : </span><span style="color: rgb(37,37,37);">services 和node的映射, </span><span style="color: rgb(37,37,37);">包括</span><span style="color: rgb(37,37,37);">vBucket map</span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">vBucket map: <span style="color: rgb(37,37,37);">vBucket和node的映射</span></span></span></span></span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><br></span></span></span></span></span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">映射函数: func(<span style="color: rgb(37,37,37);">documentID</span>) -&gt; <span style="color: rgb(37,37,37);">vBucketID</span></span></span></span></span></span></p><p><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);"><span style="color: rgb(37,37,37);">分片数量不固定, 可调整</span></span></span></span></span></span></p></td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">每个节点都知道任意文档所处的位置，并且能够将我们的请求直接转发到存储我们所需文档的节点.</span></p><p><span style="color: rgb(68,68,68);"><span>shard = hash(routing) % number_of_primary_shards</span></span></p><p><span style="color: rgb(68,68,68);"><span>其中<span style="color: rgb(68,68,68);">routing默认是文档_id, 也可以自定义</span></span></span></p><p><span style="color: rgb(68,68,68);"><span><span style="color: rgb(68,68,68);"><br></span></span></span></p><p><span style="color: rgb(68,68,68);"><span><span style="color: rgb(68,68,68);">分片数量不固定, (初始化后)不能调整</span></span></span></p><p><span style="color: rgb(68,68,68);"><span><span style="color: rgb(68,68,68);">是否限制了分片的扩展性: 可以多加index来实现分片扩展</span></span></span></p></td><td class="confluenceTd"><p>Producer:可以自己决定把消息发布到这个主题的哪个Partition</p><p><span style="color: rgb(85,85,85);">Consumer: N/A </span></p><p>&nbsp;</p><p>TODO:</p><ol style="text-align: justify;"><li>将所有Broker（假设共n个Broker）和待分配的Partition排序</li><li>将第i个Partition分配到第（i mod n）个Broker上</li><li>将第i个Partition的第j个Replica分配到第（(i + j) mod n）个Broker上</li></ol><p>&nbsp;</p><p><span style="color: rgb(37,37,37);">分片数量不固定(配置<span style="color: rgb(85,85,85);">num.partitions</span>), 可调整 (TODO</span><span style="color: rgb(37,37,37);">)</span></p></td></tr><tr><td colspan="1" class="confluenceTd"><h2 id="id-分布式系统浅析2-术语"><strong>术语</strong></h2></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd"><h2 id="id-分布式系统浅析2-特征"><strong>特征</strong></h2></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">特点</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>Cluster:</p><p>1) 高性能和线性可扩展性: 最多可达1000个node, 无代理, 异步复制<br>2) Acceptable degree of write safety: 存在极少的写丢失情况<br>3)高可用:</p><p>多数master存活+其他master有存活的slave</p><p>replicas migration: slave 借用</p></td><td colspan="1" class="confluenceTd"><p>可扩展的数据模型</p><p>1) 高可用</p><p>2) 可扩展</p><p>3) 高性能</p><p>4) 安全性</p><p>5) 多种的数据交互方式</p></td><td colspan="1" class="confluenceTd"><p>1) 分布式的实时文件存储，每个字段都被索引并可被搜索<br>2) 分布式的实时分析搜索引擎<br>3) 可以扩展到上百台服务器，处理PB级结构化或非结构化数据<br>4) 提供 RESTful API<br><br></p></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd">类型</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd"><span>内存型 KV Nosql</span></td><td class="confluenceTd"><p><span>内存型 Nosql, 同时支持KV和文档</span></p><p>文档可以认为是KV类型的V, 文档有独立于V的K, 也就是id)</p></td><td class="confluenceTd"><p><span style="color: rgb(68,68,68);">实时的分布式搜索分析引擎</span></p><p><span style="color: rgb(68,68,68);">文档型</span></p></td><td colspan="1" class="confluenceTd">消息系统</td></tr><tr><td colspan="1" class="confluenceTd"><h2 id="id-分布式系统浅析2-维护"><strong>维护</strong></h2></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">维护</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">支持在线部署, 包括升级, 伸缩(增删node), 失效转移, 监控, 压缩备份等</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd"><h2 id="id-分布式系统浅析2-网络协议与交互"><strong>网络协议与交互</strong></h2></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>&nbsp;</p></td><td colspan="1" class="confluenceTd"><a class="external-link" href="https://developer.couchbase.com/documentation/server/4.6/architecture/connectivity-architecture.html" rel="nofollow">https://developer.couchbase.com/documentation/server/4.6/architecture/connectivity-architecture.html</a></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd"><span style="color: rgb(0,0,255);">自动发现</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;<span>不能自动节点发现, 需要手动meet</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>支持</p><p>两种组网方式:</p><div class="page" title="Page 152"><div class="layoutArea"><div class="column"><p>1) multicast: 组播</p><p>2) unicast: 单播, 需要配置单播节点, 通常配master(作为gossip router)</p></div></div></div></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd">自增id</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">不支持, <span>需要客户端提供key</span></td><td class="confluenceTd"><p>不支持, 需要客户端提供key(id)</p></td><td class="confluenceTd"><p>_id可以客户端提供, 也可以自动生成</p></td><td class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">读从/复制node(读写分离)</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>GetReplica</p><p>数据可能不一致</p><p>仅用于active node 不可用</p></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd"><span style="color: rgb(0,0,255);">读扩展</span></td><td class="confluenceTd"><p>复制产生主从, 不同集群从的角色不一.</p><p>有的仅作为backup来支持<span style="color: rgb(37,37,37);">Failover</span></p><p>有的从可以支持读, 以实现主从分离.</p></td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd"><p>slave默认不提供读, 只作为备份</p><p>READONLY 选项可以水平扩展读, 其实作用有限.</p><p>利用slave扩展读可以自行在client端实现(要能忍受脏数据)</p></td><td class="confluenceTd"><p><span style="color: rgb(37,37,37);">复制分片默认不可读, 只是为高可用, 这样的好处是利于实现数据一致性.(读写同时在active分片)</span></p><p><span style="color: rgb(37,37,37);">As of Couchbase Server 2.1.0, we have a binary protocol to retrieve replicated data for a given key(客户端要能容忍数据不一致)</span></p></td><td class="confluenceTd">复制分片可以提供读和搜索</td><td class="confluenceTd"><p>leader负责读写, followers 仅作为backup</p><p>(没有必要读扩展)</p></td></tr><tr><td colspan="1" class="confluenceTd">过期时间</td><td colspan="1" class="confluenceTd"><p>1) 惰性过期: 操作指定key时, 检测过期时间, 如果已过期则删除<br>2) 主动过期: 定时过期线程扫描, 删除过期数据.</p></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">支持</td><td colspan="1" class="confluenceTd"><p>支持</p><ol><li><em class="ph i">touch</em></li><li><em class="ph i"><em class="ph i">get-and-touch</em></em><br><em><br></em></li></ol><p>注:</p><p>大多数操作会隐式去掉过期时间, 因此需要在所有写入(<span style="color: rgb(37,37,37);">mutation</span>)操作中带上过期时间<br><span style="color: rgb(37,37,37);">expiry &gt; <span style="color: rgb(37,37,37);">30 days ? <span style="color: rgb(37,37,37);">absolute Unix time stamp : <span style="color: rgb(37,37,37);">offset from the current</span></span></span></span><em class="ph i"><em class="ph i"><br></em></em></p></td><td colspan="1" class="confluenceTd"><p>不支持</p><p>某些场景下可以按照时间范围创建索引.</p><p>需要删除时直接删除整个索引.</p></td><td colspan="1" class="confluenceTd"><p>基于时间删除: 配置<span style="color: rgb(77,77,76);">log.retention.hours</span></p><p><span style="color: rgb(77,77,76);">基于partition文件大小删除: <span style="color: rgb(77,77,76);">log.segment.bytes</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">过期时间</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>GetAndTouch</p><p>Touch</p></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd"><span style="color: rgb(0,0,255);">逻辑空间</span></td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">&nbsp;</td><td class="confluenceTd">一个redis <span style="color: rgb(0,0,255);">Cluster</span> 是一个逻辑key空间</td><td class="confluenceTd"><p><span style="color: rgb(51,102,255);">Bucket</span></p><p><span style="color: rgb(37,37,37);">一个集群可以有多个逻辑空间(Bucket)</span></p><p><span style="color: rgb(37,37,37);">隔离以下实体:</span></p><p><span style="color: rgb(37,37,37);">key空间</span></p><p><span style="color: rgb(37,37,37);">cache, io管理</span></p><p><span style="color: rgb(37,37,37);">鉴权</span></p><p><span style="color: rgb(37,37,37);">XDCR</span></p><p><span style="color: rgb(37,37,37);">索引, 视图</span></p></td><td class="confluenceTd"><p><span style="color: rgb(51,102,255);">Index</span>: 实际上是指向一个或者多个物理 分片 的 逻辑命名空间</p><p><span style="color: rgb(37,37,37);">一个集群可以有多个逻辑空间(Index)</span></p><p>es 支持操作多索引, 多索引(多租户技术)是扩容的一种方案(因为主分片无法扩容)</p></td><td class="confluenceTd"><p><span style="color: rgb(51,102,255);">Topic</span></p><p><span style="color: rgb(51,102,255);"><span style="color: rgb(37,37,37);">一个集群可以有多个逻辑空间(Topic)</span></span></p></td></tr><tr><td colspan="1" class="confluenceTd">集群搭建</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p><span>redis-trib.rb </span><span class="hljs-operator"><span class="hljs-keyword" style="color: rgb(0,0,136);">create</span> --replicas</span></p></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><span style="color: rgb(68,68,68);">集群是由一个或者多个拥有相同&nbsp;</span><code class="literal"><a class="external-link" href="http://cluster.name" rel="nofollow">cluster.name</a></code><span style="color: rgb(68,68,68);">&nbsp;配置的节点组成</span></td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td class="confluenceTd">&nbsp;</td><td class="confluenceTd"><span style="color: rgb(37,37,37);">Table</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd">N/A</td><td class="confluenceTd"><span style="color: rgb(37,37,37);">Bucket or Item (with type designator attribute)</span></td><td class="confluenceTd"><span>Type</span></td><td colspan="1" class="confluenceTd">N/A</td></tr><tr><td class="confluenceTd">&nbsp;</td><td class="confluenceTd"><span style="color: rgb(37,37,37);">Row</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd"><span>N/A</span></td><td class="confluenceTd"><span style="color: rgb(37,37,37);">Item (key-value or document)</span></td><td class="confluenceTd"><span>Document</span></td><td colspan="1" class="confluenceTd"><span>N/A</span></td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><span>Column</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><span>N/A</span></td><td colspan="1" class="confluenceTd"><span style="color: rgb(37,37,37);">Document F<span>ield</span></span></td><td colspan="1" class="confluenceTd"><span>Field</span></td><td colspan="1" class="confluenceTd"><span>N/A</span></td></tr><tr><td class="confluenceTd">&nbsp;</td><td class="confluenceTd"><span style="color: rgb(37,37,37);">Index</span></td><td colspan="1" class="confluenceTd">&nbsp;</td><td class="confluenceTd"><span>N/A</span></td><td class="confluenceTd"><p>Index</p><p><span style="color: rgb(120,120,120);">&nbsp;</span></p></td><td class="confluenceTd"><span style="color: rgb(68,68,68);">倒排索引(默认的，一个文档中的每一个属性都是 被索引 的)</span></td><td colspan="1" class="confluenceTd"><span>N/A</span></td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><p>&nbsp;</p></td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd"><span style="color: rgb(85,85,85);">consistency 参数 TODO</span></td><td colspan="1" class="confluenceTd"><p><span style="color: rgb(85,85,85);">读取特定消息的时间复杂度为O(1)</span></p><p>&nbsp;</p></td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr><tr><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td><td colspan="1" class="confluenceTd">&nbsp;</td></tr></tbody></table></div>
