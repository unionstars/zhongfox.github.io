---
layout: post
tags : [机器学习, python, 读书笔记]
title: 集体智慧编程

---

集体智慧:

* 为了创造新的想法, 将一群人的行为,偏好,思想组合到一起.
* 组中的个体成员将被忽略
* 从独立的数据提供者中得到新的结论.

---

## 计算相似度

同模型相关性

### 欧几里得距离

要计算一个模型A中的不同对象的相似度, 可以根据这些对象和另外一个模型B的对象们的关系来计算, 关系则对象相似.

把关系看做空间坐标, 一个关系就是一条坐标, 关系值就是该坐标的点. 因此一个对象a1和N个B对象的关系值, 可以变成N维空间中的一个点.

a1和a2的相似度可以通过求这2点之间的距离: `sqrt(pow(关系x)+pow(关系y) ...)`

为了相似值越大, 值越大: `1/(1+ sqrt(pow(关系x)+pow(关系y) ...) )` 范围是0~1

### 皮尔逊系数

TODO

相似值越大, 值越大. 范围是0~1

---

## 推荐

不同模型相关性

给A模型对象a1推荐B模型对象, 推荐的范畴是目标对象a1还没有关系系数的B对象 b1, b2...., 其实就是对b1, b2和a1关系的预测和排序.


### 基于用户的协作型过滤

首先计算A模型中, 目标对象和其他对象的相似度. b1的预测评分为: (a2和a1相似度*a2对b1评分 + a3和a1相似度*a3对b1评分....)/(a1和a2,a3...相似度之和)

对a1来说, 就是将其他兄弟对象和B各对象的关系, 加权平均一下, 推测出自己对B对象的关系.

### 基于物品的协作型过滤

对于B模型(物品), 预先计算好(因为物品相关性变化不大?)各个对象b的相关性排序列表.

对于目标a1, 找到a1和B模型的相关性topN列表, 列表中的B对象, 对a1没有现成关系的B对象, 如bx预测关系:

(a1与b1的关系系数*b1与bx的相关性+a1与b2的关系系数*b2与bx的相关性...)/(bx与b1,b2相似度的和)


对于稀疏数据集, 基于物品的过滤方法优于基于用户过滤, 对于密集数据集, 二者差不多.

---

## 监督学习

利用样本输入和期望输出, 来学习如何预测的技术

包括:

* 神经网络
* 决策树
* 向量支持机
* 贝叶斯过滤

## 无监督学习

样本并没有正确答案, 目标是在一组数据中找寻某种结构.

包括:

* 聚类
* 非负矩阵因式分解
* 自组织映射

### 聚类

每组数据包装为最初的聚类列表, 只要聚类列表数量大于1, 进行循环, 循环体: 再两重循环(如冒泡) 计算出两两相似度(如使用皮尔逊), 对最相似的2个组合, 包装为新的聚类, 该聚类的各项数据是2者各项和再除以2, 把新的聚类append到聚类列表, 删除这2个原始聚类.

### K-均值聚类

输入除了最初的聚类列表外, 还需要一个k值, 表示期望生成的聚类群数量.

1. 先随机生成k个聚类: 每个随机聚类的各项数据计算方式, 是在原始聚类各项的(min, max)间随机.

2. 遍历原始聚类列表, 计算目标聚类和k个聚类群聚类的相似度, 把目标聚类放到最相似的聚类群后面.

3. 遍历完一遍后, 把聚类群整合: 各项值求平均值, 其实就是把聚类群聚类移到这个群的中间. 然后再反复执行2, 直到k个聚类群列表不发生变化.

在这个过程中, k个聚类的位置(各项数据)会发生变化, 又原来的随机, 慢慢变为聚类中心, 个原始聚类在这个过程中, 也可能改变所属聚类群.
